*do-vim.txt*    do-vim     Version 0.1.0    Last change: October 11 2018

DO.VIM                                                                  *do-vim*
==============================================================================

The concept is to have a group of commands that `do something`, in a way that
it makes it easy to remember their mappings, and that you can show by typing `dO`.

There is a set of commands that you can activate, but it will work with any of
your mappings. All you need to do, is to define some mappings that start with
`do`, and they will be shown when you type `dO`.

What's the difference between this and just typing `:nmap do`?

- you can set descriptions for each mapping, and the output is more readable.
- you can filter entries by pressing a key.
- it can show the files where mappings are defined.
- it can be run in interactive mode.

But you're not limited to the `do` keyword, you can do the same with any other
mapping prefix.

NOTE: using the keyword 'do' will conflict with |do| in diff mode (|:diffget|).
You could remap vim's 'do', or use another prefix instead of 'do'.



OPTIONS                                                         *do-vim-options*
==============================================================================

If you want the default commands:
>
  let g:vimdo_use_default_commands = 1

If you to change the default prefix (default `do`):
>
  let g:vimdo_default_prefix = 'do'

To show the file where the mapping is defined:
>
  let g:vimdo_show_filename = 1

To always run in interactive mode (see |do-vim-interactive|):
>
  let g:vimdo_interactive = 1

To extend default group (`do`), see next section.
To create new groups, see |do-vim-groups|.



DEFAULT COMMANDS                                                *do-vim-default*
==============================================================================

If you didn't change the default prefix, these mappings are set:
>
    dO    ( show all do's )
    doB   ( show all buffer do's )

`doB` is useful if you define new <buffer> do's in |ftplugin| files, for example.

You can call it from the command line:
>
    :ShowDos {prefix}

With a <bang>, it will also show filenames, even if `g:vimdo_show_filename` is
false:
>
    :ShowDos! {prefix}

These are the the default commands:

'dodo'  ->  do diff other file (in next window)
'dods'  ->  do diff with saved
'dodl'  ->  do diff with last git revision
'dodh'  ->  do diff with HEAD
'dorc'  ->  do redir command (command output to new buffer)
'dore'  ->  do redir expression (expression to new buffer)
'dows'  ->  do trim whitespaces
'doec'  ->  do echo color infos
'doft'  ->  do open ftplugin file (if present in $VIMDIR/ftplugin)
'dout'  ->  do update tags (runs `ctags -R .`, or `b:ctags_cmd` if defined)
'dovp'  ->  do vim profiling (first time activates, second time stops and quits)
'dossa' ->  do print syntax infos for word under cursor
'dofcr' ->  do find CR (mass find/correct files with CRLF line endings in the
            current working directory)

If you don't want all defaults, but want some of them, add them to your `vimrc`:
>
  nnoremap dows  :call do#cmd#trim_whitespaces()<cr>
  nnoremap dout  :call do#cmd#update_tags()<cr>
  nnoremap dovp  :call do#cmd#profiling()<cr>
  nnoremap dodo  :call do#diff#other()<cr>
  nnoremap dods  :call do#diff#saved()<cr>
  nnoremap dodl  :call do#diff#last_revision(0)<cr>
  nnoremap dodh  :call do#diff#last_revision(1)<cr>
  nnoremap dossa :call do#cmd#syntax_attr()<cr>
  nnoremap dofcr :call do#cmd#find_crlf(1, "")<cr>
  nnoremap dore  :call do#cmd#redir_expression()<cr>
  nnoremap doec  :call do#color#echo()<cr>
  nnoremap doft  :call do#cmd#open_ftplugin()<cr>
  nnoremap dorc  :RedirCommand<space>
  command! -nargs=* -complete=command RedirCommand call do#redir_cmd(<f-args>)

To extend default group with some other commands (example):
>
  nnoremap dorf   m`gg=G``
  nnoremap doca   :%y+<cr>
  nnoremap dosa   ggVG
  nnoremap dojpp  :%!python -m json.tool<cr>
  nnoremap dotm   :setlocal noexpandtab tabstop=20 shiftwidth=20 softtabstop=20 nowrap<cr>

  let g:vimdo = {'do':
    \'rf':  'reindent file',
    \'ca':  'copy all',
    \'sa':  'select all',
    \'jpp': 'json pretty print',
    \'tm':  'table mode',
    \}



GROUPS                                                           *do-vim-groups*
==============================================================================

An example of creating a new group:
>
  nnoremap \gr  :echo system("git reset")<cr>
  nnoremap \gs  :Gstatus<cr>
  nnoremap \gb  :Gblame<cr>
  nnoremap \gp  :redraw! <bar> echo "Pushing...\t" <bar> echon system("git push")<cr>
  nnoremap \ga  :echo system("git add .")."Git: added ."<cr>
  nnoremap \gl  :Glog<cr>
  nnoremap \gg  :Gcommit<cr>
  nnoremap \gd  :Gvdiff<Space>
  nnoremap \gC  :Gcommit --amend<cr>
  nnoremap \gA  :call system("git add .")<cr>:Gcommit --amend<cr>

  let g:vimdo = {}
  let g:vimdo['\g'] = { 'label' : 'git commands', 'require_description': 1,
    \'r':  'reset',
    \'s':  'status',
    \'b':  'blame',
    \'p':  'push',
    \'a':  'add all',
    \'l':  'log',
    \'g':  'commit',
    \'d':  'diff',
    \'C':  'amend',
    \'A':  'add all and amend',
    \}

  nnoremap \gO :call do#show_all_dos('\g')<cr>

What happens here?

- you assign your mappings, as you normally would.
- you initialize the `g:vimdo` dict (if you didn't already!)
- you create a key inside of it, that is the mapping prefix you are using.
- you populate this key with the continuation of each mapping, and set a description.
- finally you crate a mapping to show your group.



INTERACTIVE MODE                                            *do-vim-interactive*
==============================================================================

The command can be run in interactive mode if the global option is set, or if
a custom group contains the 'interactive' dictionary key.

In this case, the pressed keys will not only refilter the list, but also
trigger the mapping if a match in the list is found.



GROUP DICTIONARY                                             *do-vim-dictionary*
==============================================================================
                                                                *do-vim-label*
                                                  *do-vim-require_description*
                                                            *do-vim-arbitrary*
                                                               *do-vim-simple*

In the created dictionary, there can be these optional keys:

- `label`
- `simple`
- `interactive`
- `require_description`
- `arbitrary`

`label`: just a label for the header.

`simple`: no separators.

`interactive`: run in interactive mode.

`require_description`: that is, a dict key/value pair. May be convenient
    because, in reality, you don't need to create a dictionary at all, just
    execute:
>
    :ShowDos {prefix}
<
    and all mappings that begin with that prefix will be shown. Setting
    `require_description` prevents unwanted mappings to be shown in the list,
    but forces you to add dictionary entries for all items.

`arbitrary`: if true, the group name is not the prefix, is just a group name.
    The whole keys will be checked for a mapping, but only those ones.
    This allows you to show a set of mapping of your choosing, from the ground
    up. Pointless to use `require_description` with this one.
    For example, you could use arbitrary groups in your |ftplugin| files, to
    show mappings that you define there.



ADVANCED USAGE                                                 *do-vim-advanced*
==============================================================================
                                                              *do-vim-compact*
                                                                *do-vim-order*
                                                               *do-vim-widths*

Used to define the padding of mappings/descriptions
>
  let g:vimdo_keys_width = 16
  let g:vimdo_desc_width = 40

More optional group dictionary keys:

- `compact`
- `order`
- `keys_width`
- `desc_width`

`compact`: lets you show a group in a compact way, on multiple columns, without
    showing the {rhs} of the mapping, only the trigger and the description.
    Note: if `compact` is set, `require_description` is also considered true.

`order`: since dictionaries don't preserve order, this key can hold the order
    in which you want the group to be shown. All group mappings must be
    present in this list, or it will fail.

`keys_width` and `desc_width`: especially useful to set for a group, when
    using compact mode.

Finally, you can define a command in the group dictionary, without having
defined a mapping for it. This allows the creation of totally arbitrary
groups. To do this, the dictionary element must contain:
>
    {key} : [ {description}, {noremap}, {rhs} ]

Note: with this system, you can also create contextual menus that execute
custom commands at keypress!

Note: this kind of menu requires `arbitrary` to be set in the group.

Note: when writing the {rhs} of the custom command, if any special character
is present, the {rhs} must use `double quotes` and the special characters must
be escaped. Only the following ones are accepted:

    <cr>      -> `"\<cr>"`
    <space>   -> `"\<space>"`
    <bar>     -> `"\<bar>"`



EXAMPLES                                                       *do-vim-examples*
==============================================================================

For this example, `vim-fugitive` is needed.
An example of arbitrary and interactive group with git commands:
>
    nnoremap \G :ShowDos \G<cr>

    let g:vimdo['\G'] = {
          \'label' : 'git commands', 'interactive':1, 'arbitrary': 1,
          \'compact':1, 'keys_width': 8, 'desc_width': 30,
					\'order': split('scarbplw.dDA', '\zs'),
          \'s':  ['status', 0, ":Gstatus\<cr>"],
					\'c':  ['commit', 0, ":Gcommit\<cr>"],
					\'a':  ['amend', 0, ":Gstatus\<cr>ca\<cr>"],
          \'r':  ['reset', 0, ":echo system('git reset')\<cr>"],
          \'b':  ['blame', 0, ":Gblame\<cr>"],
          \'p':  ['push', 0, ":redraw! \<bar> echo 'Pushing...\t' \<bar> echon system('git push')\<cr>"],
          \'l':  ['log current file', 0, ":Glog\<cr>"],
          \'w':  ['stage file', 0, ":Gwrite\<cr>"],
          \'.':  ['add all', 0, ":echo system('git add .').'Git: added .'\<cr>"],
          \'d':  ['diff with...', 0, ":Gvdiff\<space>"],
          \'D':  ['diff HEAD', 0, ":Gvsplit! diff HEAD\<cr>:setf git\<cr>:set foldmethod=syntax\<cr>"],
          \'A':  ['add all and amend', 0, ":call system('git add .')\<cr>:Gcommit --amend\<cr>:q\<cr>"],
          \}


==============================================================================
vim:tw=78:sw=2:ts=2:ft=help:norl:nowrap:
